---
Title: OllyDbg
Date: 26-08-2025
Author: Alex Nevin
---

Writing up a quick run-through of OllyDbg for a personal reference and information capturing. 
I'm sitting a Malware Analysis unit for University and had some trouble with navigating OllyDbg. 

### Environment
I'm running VMWare Workstation with a Win10 machine equiped with some handy malware analysis tools.
There's a rollback snapshot stored within VMWare so I can recover as needed. 

# Reverse Engineer with IDA
Let's try work through a simple program without reviewing any original source code.

We'll pop open our executable in IDA and hunt for our main function:
![Overview]("https://github.com/voided323/skills-github-pages/blob/main/_posts/Images/OllyDbg/2025-08-26 19_32_06-Overview.png?raw=true") 

From here we can see that there's some kind of control flow that, after an evaluation, prints either "You Won!" or "You Lost.".
Looking at the diagram, there's a *cmp* flag which indicates an **if** statement occurs, controlling the remaining flow:
![Compare statement](https://github.com/voided323/skills-github-pages/blob/main/_posts/Images/OllyDbg/2025-08-26 19_35_06-CMP_Call.png?raw=true)

This works out as: Compare the value in the eax register to 1. If equal, print "You Won!", else print "You Lost.".

Further to this, we can confirm that the default behaviour of the program is to lose. Using Ida, we'll investigate the call function directly above the cmp function:
![Push Eax](https://github.com/voided323/skills-github-pages/blob/main/_posts/Images/OllyDbg/2025-08-26 19_37_52-Push_Eax?raw=true)

This simple function pushes the value "2" onto the EAX register, causing the comparison to evalutate to False.

# Exploit with OllyDbg 
Now that we've analysed the behaviour with IDA, we'll open the executable in OllyDbg to change the EAX value at run time.

![OllyDbg Home](https://github.com/voided323/skills-github-pages/blob/main/_posts/Images/OllyDbg/2025-08-26 19_44_49-OllyDbg_Home.png?raw=true)
The above screen shows our crackme2.exe file running in the background, with our OllyDbg and assembly code viewer running in the foreground.


Using the keyboard shortcut Alt+M to open the memory map viewer, we'll locate our program entry point for further analysis:
![OllyDbg Memory map](https://github.com/voided323/skills-github-pages/blob/main/_posts/Images/OllyDbg/2025-08-26 19_46_58-OllyDbg_Locate_Entry.png?raw=true)

By selecting **view in dissassembler** on the entry point, we are taken directly to our main function entry.
From here, we'll locate the memory address for the **cmp** instruction, and set a breakpoint with the F2 keyboard shortcut:
![OllyDbg cmp Instruction](https://github.com/voided323/skills-github-pages/blob/main/_posts/Images/OllyDbg/2025-08-26 21_18_14-OllyDbg_Cmp_Instruction.png?raw=true)

Now we'll run the program. Once we hit the breakpoint, we'll edit the EAX register in the right-hand window, and set it to the value in the **cmp** function ("1"):
![OllyDbg Change EAX](https://github.com/voided323/skills-github-pages/blob/main/_posts/Images/OllyDbg/2025-08-26 21_22_13-OllyDbg_Eax_Change.png?raw=true)

Now we'll continue running the application and receive the "You Won!" message 
